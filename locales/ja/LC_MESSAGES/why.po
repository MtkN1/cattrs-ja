# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Tin TvrtkoviÄ‡
# This file is distributed under the same license as the cattrs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: cattrs 24.1.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-24 22:39+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../downloads/cattrs/docs/why.md:1
msgid "Why *cattrs*?"
msgstr "*cattrs* ãŒå¿…è¦ãªç†ç”±"

#: ../../downloads/cattrs/docs/why.md:3
msgid "Python has a rich set of powerful, easy to use, built-in **unstructured** data types like dictionaries, lists and tuples. These data types effortlessly convert into common serialization formats like JSON, MessagePack, CBOR, YAML or TOML."
msgstr "Python ã«ã¯ã€è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ãªã©ã€å¼·åŠ›ã§ä½¿ã„ã‚„ã™ã„çµ„ã¿è¾¼ã¿ã® **éæ§‹é€ åŒ–** ãƒ‡ãƒ¼ã‚¿å‹ãŒè±Šå¯Œã«ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€JSONã€MessagePackã€CBORã€YAMLã€TOML ãªã©ã®ä¸€èˆ¬çš„ãªã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå½¢å¼ã«ç°¡å˜ã«å¤‰æ›ã§ãã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:6
msgid "But the data that is used by your **business logic** should be **structured** into well-defined classes, since not all combinations of field names or values are valid inputs to your programs. The more trust you can have into the structure of your data, the simpler your code can be, and the fewer edge cases you have to worry about."
msgstr "ã—ã‹ã—ã€**ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯** ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ã€æ˜ç¢ºã«å®šç¾©ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã« **æ§‹é€ åŒ–** ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚ãªãœãªã‚‰ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚„å€¤ã®ã™ã¹ã¦ã®çµ„ã¿åˆã‚ã›ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¸ã®æœ‰åŠ¹ãªå…¥åŠ›ã¨ãªã‚‹ã‚ã‘ã§ã¯ãªã„ã‹ã‚‰ã§ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ã‚’ã‚ˆã‚Šä¿¡é ¼ã§ãã‚‹ã»ã©ã€ã‚³ãƒ¼ãƒ‰ã¯ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚Šã€å¿ƒé…ã™ã‚‹å¿…è¦ã®ã‚ã‚‹ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã¯å°‘ãªããªã‚Šã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:9
msgid "When you're handed unstructured data (by your network, file system, database, ...), _cattrs_ helps to convert this data into trustworthy structured data. When you have to convert your structured data into data types that other libraries can handle, _cattrs_ turns your classes and enumerations into dictionaries, integers and strings."
msgstr "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãªã©ã‹ã‚‰éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã£ãŸå ´åˆã€_cattrs_ ã¯ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿¡é ¼ã§ãã‚‹æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä»–ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå‡¦ç†ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€_cattrs_ ã¯ã‚¯ãƒ©ã‚¹ã¨åˆ—æŒ™å‹ã‚’è¾æ›¸ã€æ•´æ•°ã€æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:12
msgid "_attrs_ (and to a certain degree dataclasses) are excellent libraries for declaratively describing the structure of your data, but they're purposefully not serialization libraries. *cattrs* is there for you the moment your `attrs.asdict(your_instance)` and `YourClass(**data)` start failing you because you need more control over the conversion process."
msgstr "_attrs_ (ãã—ã¦ã‚ã‚‹ç¨‹åº¦ã¯ dataclasses) ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ã‚’å®£è¨€çš„ã«è¨˜è¿°ã™ã‚‹ãŸã‚ã®å„ªã‚ŒãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ãŒã€æ„å›³çš„ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`attrs.asdict(your_instance)` ã¨ `YourClass(**data)` ãŒã€å¤‰æ›ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚ˆã‚Šç´°ã‹ãåˆ¶å¾¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã«å¤±æ•—ã—å§‹ã‚ãŸã¨ãã€*cattrs* ãŒå½¹ã«ç«‹ã¡ã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:16
msgid "Examples"
msgstr "ä¾‹"

#: ../../downloads/cattrs/README.md:1144
msgid "_cattrs_ works best with [_attrs_](https://www.attrs.org/) classes, and [dataclasses](https://docs.python.org/3/library/dataclasses.html) where simple (un-)structuring works out of the box, even for nested data, without polluting your data model with serialization details:"
msgstr "_cattrs_ ã¯ã€[_attrs_](https://www.attrs.org/) ã‚¯ãƒ©ã‚¹ã‚„ [dataclasses](https://docs.python.org/3/library/dataclasses.html) ã¨ã®çµ„ã¿åˆã‚ã›ã§æœ€é«˜ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç™ºæ®ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã€å˜ç´”ãª (é) æ§‹é€ åŒ–ãŒã€ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã§ã‚ã£ã¦ã‚‚ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã®è©³ç´°ã§ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’æ±šæŸ“ã™ã‚‹ã“ã¨ãªãã€ã™ãã«åˆ©ç”¨ã§ãã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:24
msgid "Note how the structuring and unstructuring details do **not** pollute your class, meaning: your data model. Any needs to configure the conversion are done within *cattrs* itself, not within your data model."
msgstr "æ§‹é€ åŒ–ã¨éæ§‹é€ åŒ–ã®è©³ç´°ãŒã‚¯ãƒ©ã‚¹ã€ã¤ã¾ã‚Šãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’æ±šæŸ“ **ã—ãªã„** ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚å¤‰æ›ã‚’æ§‹æˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å†…ã§ã¯ãªãã€*cattrs* è‡ªä½“ã®ä¸­ã§è¡Œã‚ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:27
msgid "There are popular validation libraries for Python that couple your data model with its validation and serialization rules based on, for example, web APIs. We think that's the wrong approach. Validation and serializations are concerns of the edges of your program â€“ not the core. They should neither apply design pressure on your business code, nor affect the performance of your code through unnecessary validation. In bigger real-world code bases it's also common for data coming from multiple sources that need different validation and serialization rules."
msgstr "Python ã«ã¯ã€Web API ãªã©ã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œè¨¼ãŠã‚ˆã³ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«ã¨çµåˆã™ã‚‹ã€ä¸€èˆ¬çš„ãªæ¤œè¨¼ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚Šã¾ã™ã€‚ç§ãŸã¡ã¯ãã‚Œã¯é–“é•ã£ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒã ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚æ¤œè¨¼ã¨ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒƒã‚¸ã«é–¢ã™ã‚‹ã‚‚ã®ã§ã‚ã‚Šã€ã‚³ã‚¢ã«é–¢ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã¯ã€ãƒ“ã‚¸ãƒã‚¹ã‚³ãƒ¼ãƒ‰ã«è¨­è¨ˆä¸Šã®åœ§åŠ›ã‚’ã‹ã‘ã‚‹ã¹ãã§ã¯ãªãã€ä¸å¿…è¦ãªæ¤œè¨¼ã«ã‚ˆã£ã¦ã‚³ãƒ¼ãƒ‰ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã¹ãã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚å¤§è¦æ¨¡ãªå®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã§ã¯ã€ç•°ãªã‚‹æ¤œè¨¼ãŠã‚ˆã³ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«ã‚’å¿…è¦ã¨ã™ã‚‹è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚‚ä¸€èˆ¬çš„ã§ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:33
msgid "ğŸ¶ You gotta keep 'em separated. ğŸ¶"
msgstr "ğŸ¶ åˆ†é›¢ã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚ ğŸ¶"

#: ../../downloads/cattrs/docs/why.md:37
msgid "*cattrs* also works with the usual Python collection types like dictionaries, lists, or tuples when you want to **normalize** unstructured data data into a certain (still unstructured) shape. For example, to convert a list of a float, an int and a string into a tuple of ints:"
msgstr "*cattrs* ã¯ã€éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ç‰¹å®šã® (ã¾ã éæ§‹é€ åŒ–ã•ã‚ŒãŸ) å½¢çŠ¶ã« **æ­£è¦åŒ–** ã—ãŸã„å ´åˆã«ã€è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ã‚¿ãƒ—ãƒ«ãªã©ã®é€šå¸¸ã® Python ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã§ã‚‚æ©Ÿèƒ½ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€floatã€intã€ãŠã‚ˆã³æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã‚’ int ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã™ã‚‹ã«ã¯:"

#: ../../downloads/cattrs/docs/why.md:48
msgid "Finally, here's a much more complex example, involving _attrs_ classes where _cattrs_ interprets the type annotations to structure and unstructure the data correctly, including Enums and nested data structures:"
msgstr "æœ€å¾Œã«ã€_attrs_ ã‚¯ãƒ©ã‚¹ã‚’å«ã‚€ã€ã¯ã‚‹ã‹ã«è¤‡é›‘ãªä¾‹ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€_cattrs_ ã¯å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è§£é‡ˆã—ã¦ã€Enum ã‚„ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ã‚’æ­£ã—ãæ§‹é€ åŒ–ãŠã‚ˆã³éæ§‹é€ åŒ–ã—ã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:88
msgid "Consider unstructured data a low-level representation that needs to be converted to structured data to be handled, and use `structure()`. When you're done, `unstructure()` the data to its unstructured form and pass it along to another library or module."
msgstr "éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã¯ã€å‡¦ç†ã™ã‚‹ãŸã‚ã«æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ä½ãƒ¬ãƒ™ãƒ«ã®è¡¨ç¾ã§ã‚ã‚‹ã¨è€ƒãˆã€`structure()` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚å®Œäº†ã—ãŸã‚‰ã€ãƒ‡ãƒ¼ã‚¿ã‚’ `unstructure()` ã—ã¦éæ§‹é€ åŒ–å½¢å¼ã«ã—ã€åˆ¥ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ¸¡ã—ã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1862
msgid "Features"
msgstr "ç‰¹å¾´"

#: ../../downloads/cattrs/README.md:1864
msgid "Recursive Unstructuring"
msgstr "å†å¸°çš„ãªéæ§‹é€ åŒ–"

#: ../../downloads/cattrs/README.md:1866
msgid "_attrs_ classes and dataclasses are converted into dictionaries in a way similar to `attrs.asdict()`, or into tuples in a way similar to `attrs.astuple()`."
msgstr "_attrs_ ã‚¯ãƒ©ã‚¹ã¨ dataclasses ã¯ã€`attrs.asdict()` ã¨åŒæ§˜ã®æ–¹æ³•ã§è¾æ›¸ã«å¤‰æ›ã•ã‚Œã‚‹ã‹ã€`attrs.astuple()` ã¨åŒæ§˜ã®æ–¹æ³•ã§ã‚¿ãƒ—ãƒ«ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1867
msgid "Enumeration instances are converted to their values."
msgstr "åˆ—æŒ™å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã‚Œã‚‰ã®å€¤ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1868
msgid "Other types are let through without conversion. This includes types such as integers, dictionaries, lists and instances of non-_attrs_ classes."
msgstr "ä»–ã®å‹ã¯ã€å¤‰æ›ãªã—ã§ãã®ã¾ã¾ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã¯ã€æ•´æ•°ã€è¾æ›¸ã€ãƒªã‚¹ãƒˆã€ãŠã‚ˆã³ _attrs_ ã‚¯ãƒ©ã‚¹ä»¥å¤–ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã©ã®å‹ãŒå«ã¾ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1869
msgid "Custom converters for any type can be registered using `register_unstructure_hook`."
msgstr "ä»»æ„ã®å‹ã®ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯ã€`register_unstructure_hook` ã‚’ä½¿ç”¨ã—ã¦ç™»éŒ²ã§ãã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1872
msgid "Recursive Structuring"
msgstr "å†å¸°çš„ãªæ§‹é€ åŒ–"

#: ../../downloads/cattrs/README.md:1874
msgid "Converts unstructured data into structured data, recursively, according to your specification given as a type. The following types are supported:"
msgstr "éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ã€å‹ã¨ã—ã¦æŒ‡å®šã•ã‚ŒãŸä»•æ§˜ã«å¾“ã£ã¦ã€å†å¸°çš„ã«æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚æ¬¡ã®å‹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™:"

#: ../../downloads/cattrs/README.md:1877
msgid "`typing.Optional[T]` and its 3.10+ form, `T | None`."
msgstr "`typing.Optional[T]` ãŠã‚ˆã³ãã® 3.10 ä»¥é™ã®å½¢å¼ã§ã‚ã‚‹ `T | None`ã€‚"

#: ../../downloads/cattrs/README.md:1878
msgid "`list[T]`, `typing.List[T]`, `typing.MutableSequence[T]`, `typing.Sequence[T]` convert to a lists."
msgstr "`list[T]`ã€`typing.List[T]`ã€`typing.MutableSequence[T]`ã€`typing.Sequence[T]` ã¯ãƒªã‚¹ãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1879
msgid "`tuple` and `typing.Tuple` (both variants, `tuple[T, ...]` and `tuple[X, Y, Z]`)."
msgstr "`tuple` ãŠã‚ˆã³ `typing.Tuple` (ä¸¡æ–¹ã®ãƒãƒªã‚¢ãƒ³ãƒˆã€`tuple[T, ...]` ãŠã‚ˆã³ `tuple[X, Y, Z]`)ã€‚"

#: ../../downloads/cattrs/README.md:1880
msgid "`set[T]`, `typing.MutableSet[T]`, and `typing.Set[T]` convert to a sets."
msgstr "`set[T]`ã€`typing.MutableSet[T]`ã€ãŠã‚ˆã³ `typing.Set[T]` ã¯ã‚»ãƒƒãƒˆã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1881
msgid "`frozenset[T]`, and `typing.FrozenSet[T]` convert to a frozensets."
msgstr "`frozenset[T]` ãŠã‚ˆã³ `typing.FrozenSet[T]` ã¯ frozenset ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1882
msgid "`dict[K, V]`, `typing.Dict[K, V]`, `typing.MutableMapping[K, V]`, and `typing.Mapping[K, V]` convert to a dictionaries."
msgstr "`dict[K, V]`ã€`typing.Dict[K, V]`ã€`typing.MutableMapping[K, V]`ã€ãŠã‚ˆã³ `typing.Mapping[K, V]` ã¯è¾æ›¸ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1883
msgid "[`typing.TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict), ordinary and generic."
msgstr "[`typing.TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)ã€é€šå¸¸ãŠã‚ˆã³ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã€‚"

#: ../../downloads/cattrs/README.md:1884
msgid "[`typing.NewType`](https://docs.python.org/3/library/typing.html#newtype)"
msgstr "[`typing.NewType`](https://docs.python.org/3/library/typing.html#newtype)"

#: ../../downloads/cattrs/README.md:1885
msgid "[PEP 695 type aliases](https://docs.python.org/3/library/typing.html#type-aliases) on 3.12+"
msgstr "[PEP 695 å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹](https://docs.python.org/3/library/typing.html#type-aliases) (3.12 ä»¥é™)"

#: ../../downloads/cattrs/README.md:1886
msgid "_attrs_ classes with simple attributes and the usual `__init__`[^simple]."
msgstr "å˜ç´”ãªå±æ€§ã¨é€šå¸¸ã® `__init__`[^simple] ã‚’æŒã¤ _attrs_ ã‚¯ãƒ©ã‚¹ã€‚"

#: ../../downloads/cattrs/README.md:1887
msgid "All _attrs_ classes and dataclasses with the usual `__init__`, if their complex attributes have type metadata."
msgstr "é€šå¸¸ã® `__init__` ã‚’æŒã¤ã™ã¹ã¦ã® _attrs_ ã‚¯ãƒ©ã‚¹ã¨ dataclasses (ãã‚Œã‚‰ã®è¤‡é›‘ãªå±æ€§ãŒå‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ)ã€‚"

#: ../../downloads/cattrs/README.md:1888
msgid "Unions of supported _attrs_ classes, given that all of the classes have a unique field."
msgstr "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ _attrs_ ã‚¯ãƒ©ã‚¹ã® Union (ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ãŒä¸€æ„ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ)ã€‚"

#: ../../downloads/cattrs/README.md:1889
msgid "Unions of anything, if you provide a disambiguation function for it."
msgstr "ä»»æ„ã®ã‚‚ã®ã® Union (ãã‚Œã«å¯¾ã™ã‚‹æ›–æ˜§ã•å›é¿é–¢æ•°ã‚’æä¾›ã™ã‚‹å ´åˆ)ã€‚"

#: ../../downloads/cattrs/README.md:1890
msgid "Custom converters for any type can be registered using `register_structure_hook`."
msgstr "ä»»æ„ã®å‹ã®ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¯ã€`register_structure_hook` ã‚’ä½¿ç”¨ã—ã¦ç™»éŒ²ã§ãã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1895
msgid "Batteries Included"
msgstr "æ¨™æº–æ·»ä»˜"

#: ../../downloads/cattrs/README.md:1897
msgid "_cattrs_ comes with pre-configured converters for a number of serialization libraries, including JSON (standard library, [_orjson_](https://pypi.org/project/orjson/), [UltraJSON](https://pypi.org/project/ujson/)), [_msgpack_](https://pypi.org/project/msgpack/), [_cbor2_](https://pypi.org/project/cbor2/), [_bson_](https://pypi.org/project/bson/), [PyYAML](https://pypi.org/project/PyYAML/), [_tomlkit_](https://pypi.org/project/tomlkit/) and [_msgspec_](https://pypi.org/project/msgspec/) (supports only JSON at this time)."
msgstr "_cattrs_ ã«ã¯ã€JSON (æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€[_orjson_](https://pypi.org/project/orjson/)ã€[UltraJSON](https://pypi.org/project/ujson/))ã€[_msgpack_](https://pypi.org/project/msgpack/)ã€[_cbor2_](https://pypi.org/project/cbor2/)ã€[_bson_](https://pypi.org/project/bson/)ã€[PyYAML](https://pypi.org/project/PyYAML/)ã€[_tomlkit_](https://pypi.org/project/tomlkit/)ã€[_msgspec_](https://pypi.org/project/msgspec/) (ç¾æ™‚ç‚¹ã§ã¯ JSON ã®ã¿ã‚’ã‚µãƒãƒ¼ãƒˆ) ãªã©ã€å¤šæ•°ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç”¨ã«äº‹å‰æ§‹æˆã•ã‚ŒãŸã‚³ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ãŒä»˜å±ã—ã¦ã„ã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1899
msgid "For details, see the [cattrs.preconf package](https://catt.rs/en/stable/preconf.html)."
msgstr "è©³ç´°ã«ã¤ã„ã¦ã¯ã€[cattrs.preconf ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸](https://catt.rs/en/stable/preconf.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"

#: ../../downloads/cattrs/README.md:1902
msgid "Design Decisions"
msgstr "è¨­è¨ˆä¸Šã®æ±ºå®š"

#: ../../downloads/cattrs/README.md:1904
msgid "_cattrs_ is based on a few fundamental design decisions:"
msgstr "_cattrs_ ã¯ã€ã„ãã¤ã‹ã®åŸºæœ¬çš„ãªè¨­è¨ˆä¸Šã®æ±ºå®šã«åŸºã¥ã„ã¦ã„ã¾ã™:"

#: ../../downloads/cattrs/README.md:1906
msgid "Un/structuring rules are separate from the models. This allows models to have a one-to-many relationship with un/structuring rules, and to create un/structuring rules for models which you do not own and you cannot change. (_cattrs_ can be configured to use un/structuring rules from models using the [`use_class_methods` strategy](https://catt.rs/en/latest/strategies.html#using-class-specific-structure-and-unstructure-methods).)"
msgstr "éæ§‹é€ åŒ–/æ§‹é€ åŒ–ãƒ«ãƒ¼ãƒ«ã¯ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰åˆ†é›¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«ã¯éæ§‹é€ åŒ–/æ§‹é€ åŒ–ãƒ«ãƒ¼ãƒ«ã¨ä¸€å¯¾å¤šã®é–¢ä¿‚ã‚’æŒã¤ã“ã¨ãŒã§ãã€æ‰€æœ‰ã—ã¦ãŠã‚‰ãšå¤‰æ›´ã§ããªã„ãƒ¢ãƒ‡ãƒ«ã®éæ§‹é€ åŒ–/æ§‹é€ åŒ–ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã§ãã¾ã™ã€‚(_cattrs_ ã¯ã€[`use_class_methods` æˆ¦ç•¥](https://catt.rs/en/latest/strategies.html#using-class-specific-structure-and-unstructure-methods) ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰éæ§‹é€ åŒ–/æ§‹é€ åŒ–ãƒ«ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«æ§‹æˆã§ãã¾ã™ã€‚)"

#: ../../downloads/cattrs/README.md:1909
msgid "Invent as little as possible; reuse existing ordinary Python instead. For example, _cattrs_ did not have a custom exception type to group exceptions until the sanctioned Python [`exceptiongroups`](https://docs.python.org/3/library/exceptions.html#ExceptionGroup). A side-effect of this design decision is that, in a lot of cases, when you're solving _cattrs_ problems you're actually learning Python instead of learning _cattrs_."
msgstr "å¯èƒ½ãªé™ã‚Šç™ºæ˜ã‚’æ§ãˆã€ä»£ã‚ã‚Šã«æ—¢å­˜ã®é€šå¸¸ã® Python ã‚’å†åˆ©ç”¨ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€_cattrs_ ã«ã¯ã€èªå¯ã•ã‚ŒãŸ Python ã® [`exceptiongroups`](https://docs.python.org/3/library/exceptions.html#ExceptionGroup) ãŒç™»å ´ã™ã‚‹ã¾ã§ã€ä¾‹å¤–ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–å‹ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã®è¨­è¨ˆä¸Šã®æ±ºå®šã®å‰¯ä½œç”¨ã¨ã—ã¦ã€å¤šãã®å ´åˆã€_cattrs_ ã®å•é¡Œã‚’è§£æ±ºã—ã¦ã„ã‚‹ã¨ãã«ã€å®Ÿéš›ã«ã¯ _cattrs_ ã‚’å­¦ç¿’ã™ã‚‹ã®ã§ã¯ãªãã€Python ã‚’å­¦ç¿’ã—ã¦ã„ã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1912
msgid "Resist the temptation to guess. If there are two ways of solving a problem, _cattrs_ should refuse to guess and let the user configure it themselves."
msgstr "æ¨æ¸¬ã™ã‚‹èª˜æƒ‘ã«æŠµæŠ—ã—ã¦ãã ã•ã„ã€‚å•é¡Œã‚’è§£æ±ºã™ã‚‹æ–¹æ³•ãŒ 2 ã¤ã‚ã‚‹å ´åˆã€_cattrs_ ã¯æ¨æ¸¬ã‚’æ‹’å¦ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ãŒæ§‹æˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚"

#: ../../downloads/cattrs/README.md:1915
msgid "A foolish consistency is the hobgoblin of little minds, so these decisions can and are sometimes broken, but they have proven to be a good foundation."
msgstr "æ„šã‹ãªä¸€è²«æ€§ã¯ã€å°ã•ãªå¿ƒã®é¬¼ã§ã™ã€‚ã—ãŸãŒã£ã¦ã€ã“ã‚Œã‚‰ã®æ±ºå®šã¯ç ´ã‚‰ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€è‰¯ã„åŸºç›¤ã§ã‚ã‚‹ã“ã¨ãŒè¨¼æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚"

#: ../../downloads/cattrs/docs/why.md:99
msgid "Additional Documentation and Talks"
msgstr "è¿½åŠ ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨è¬›æ¼”"

#: ../../downloads/cattrs/docs/why.md:101
msgid "[On structured and unstructured data, or the case for cattrs](https://threeofwands.com/on-structured-and-unstructured-data-or-the-case-for-cattrs/)"
msgstr "[æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã¨éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã€ã¾ãŸã¯ cattrs ã®äº‹ä¾‹](https://threeofwands.com/on-structured-and-unstructured-data-or-the-case-for-cattrs/)"

#: ../../downloads/cattrs/docs/why.md:102
msgid "[Why I use attrs instead of pydantic](https://threeofwands.com/why-i-use-attrs-instead-of-pydantic/)"
msgstr "[pydantic ã®ä»£ã‚ã‚Šã« attrs ã‚’ä½¿ç”¨ã™ã‚‹ç†ç”±](https://threeofwands.com/why-i-use-attrs-instead-of-pydantic/)"

#: ../../downloads/cattrs/docs/why.md:103
msgid "[cattrs I: un/structuring speed](https://threeofwands.com/why-cattrs-is-so-fast/)"
msgstr "[cattrs I: éæ§‹é€ åŒ–/æ§‹é€ åŒ–ã®é€Ÿåº¦](https://threeofwands.com/why-cattrs-is-so-fast/)"

#: ../../downloads/cattrs/docs/why.md:104
msgid "[Python has a macro language - it's Python (PyCon IT 2022)](https://www.youtube.com/watch?v=UYRSixikUTo)"
msgstr "[Python ã«ã¯ãƒã‚¯ãƒ­è¨€èªãŒã‚ã‚‹ - ãã‚Œã¯ Python (PyCon IT 2022)](https://www.youtube.com/watch?v=UYRSixikUTo)"

#: ../../downloads/cattrs/docs/why.md:105
msgid "[Intro to cattrs 23.1](https://threeofwands.com/intro-to-cattrs-23-1-0/)"
msgstr "[cattrs 23.1 ã®ç´¹ä»‹](https://threeofwands.com/intro-to-cattrs-23-1-0/)"

#: ../../downloads/cattrs/README.md:1892
msgid "Simple attributes are attributes that can be assigned unstructured data, like numbers, strings, and collections of unstructured data."
msgstr "å˜ç´”ãªå±æ€§ã¯ã€æ•°å€¤ã€æ–‡å­—åˆ—ã€ãŠã‚ˆã³éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãªã©ã€éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã‚‹å±æ€§ã§ã™ã€‚"

